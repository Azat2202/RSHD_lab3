#set text(
  font: "Times New Roman",
  size: 14pt
)
#set quote(block: true)

#align(center)[Министерство науки и высшего образования Российской Федерации]
#align(center)[Федеральное государственное автономное образовательное учреждение]
#align(center)[Высшего образования]
#align(center)[_Факультет Программной Инженерии и Компьютерной Техники_]

#v(8em)

#align(center)[*Лабораторная работа 3 по РСХД*]
#align(center)[Вариант 51486]

#v(8em)

#align(right)[Группа: P3316]
#align(right)[Выполнили:]
#align(right)[Сиразетдинов, Шпинева]
#align(right)[Проверил:]
#align(right)[Николаев В.В.]

#v(8em)

#align(center)[г. Санкт-Петербург]
#align(center)[2025]

#pagebreak()

= Задание

== Цель работы

Цель работы - настроить процедуру периодического резервного копирования базы данных, сконфигурированной в ходе
выполнения лабораторной работы №2, а также разработать и отладить сценарии восстановления в случае сбоев.

Узел из предыдущей лабораторной работы используется в качестве основного. Новый узел используется в качестве резервного.
Учётные данные для подключения к новому узлу выдаёт преподаватель. В сценариях восстановления необходимо использовать
копию данных, полученную на первом этапе данной лабораторной работы.

== Этап 1. Резервное копирование
- Настроить резервное копирование с основного узла на резервный следующим образом:
Периодические полные копии + непрерывное архивирование.
Включить для СУБД режим архивирования WAL; настроить копирование WAL (```scp```) на резервный узел; настроить полное
резервное копирование (pg_basebackup) по расписанию (cron) раз в неделю. Созданные полные копии должны сразу
копироваться (scp) на резервный хост. Срок хранения копий на основной системе - 1 неделя, на резервной - 4 недели.
По истечении срока хранения, старые архивы и неактуальные WAL должны автоматически уничтожаться.

- Подсчитать, каков будет объем резервных копий спустя месяц работы системы, исходя из следующих условий:
Средний объем новых данных в БД за сутки: 350МБ.
Средний объем измененных данных за сутки: 800МБ.
- Проанализировать результаты.

== Этап 2. Потеря основного узла
Этот сценарий подразумевает полную недоступность основного узла. Необходимо восстановить работу СУБД на РЕЗЕРВНОМ узле,
продемонстрировать успешный запуск СУБД и доступность данных.

== Этап 3. Повреждение файлов БД
Этот сценарий подразумевает потерю данных (например, в результате сбоя диска или файловой системы) при сохранении
доступности основного узла. Необходимо выполнить полное восстановление данных из резервной копии и перезапустить СУБД
на ОСНОВНОМ узле.

Ход работы:

- Симулировать сбой:
    - удалить с диска директорию WAL со всем содержимым.
- Проверить работу СУБД, доступность данных, перезапустить СУБД, проанализировать результаты.
- Выполнить восстановление данных из резервной копии, учитывая следующее условие:
    - исходное расположение дополнительных табличных пространств недоступно - разместить в другой директории и
    скорректировать конфигурацию.
- Запустить СУБД, проверить работу и доступность данных, проанализировать результаты.

== Этап 4. Логическое повреждение данных
Этот сценарий подразумевает частичную потерю данных (в результате нежелательной или ошибочной операции) при сохранении
 доступности основного узла. Необходимо выполнить восстановление данных на ОСНОВНОМ узле следующим способом:

- Генерация файла на резервном узле с помощью pg_dump и последующее применение файла на основном узле.

Ход работы:
- В каждую таблицу базы добавить 2-3 новые строки, зафиксировать результат.
- Зафиксировать время и симулировать ошибку:
    - в любой таблице с внешними ключами подменить значения ключей на случайные (INSERT, UPDATE)
- Продемонстрировать результат.
- Выполнить восстановление данных указанным способом.
- Продемонстрировать и проанализировать результат.


= Выполнение

== Этап 1. Резервное копирование

На основном узле зададим параметры для архивации WAL файлов и их копирования на резервный узел:
```conf
wal_level = replica
archive_mode = on
archive_command = 'scp %p postgres1@pg114:/var/db/postgres1/wal_archive/%f'
```

Подключимся как суперпользователь
```sh
psql -h localhost -p 9455 -U postgres0 -d postgres
```
Создадим роль replicator с правами на репликацию:
```sql
CREATE ROLE replicator WITH REPLICATION LOGIN PASSWORD
'pass123';
```
Напишем скрипт для создания копии:
```sh
#!/bin/bash
# Директория для хранения резервных копий на основном узле
LOCAL_BACKUP_DIR="/var/db/postgres0/backups/$(date +%Y-%m-%d_%H-%M-%S)"
# Директория для хранения резервных копий на резервном узле
REMOTE_BACKUP_DIR="/var/db/postgres1/backups/$(date +%Y-%m-%d_%H-%M-%S)"
# Создание директории на основном узле
mkdir -p $LOCAL_BACKUP_DIR
# Создание директории на резервном узле
ssh pg1 "mkdir -p $REMOTE_BACKUP_DIR"

# Выполнение резервного копирования на основном узле
pg_basebackup -D $LOCAL_BACKUP_DIR -Ft -z -Xs -P -U replicator -h pg109 -p 9455
# Проверка успешности выполнения
if [ $? -eq 0 ]; then
  echo "Резервное копирование успешно завершено на основном узле: $LOCAL_BACKUP_DIR"
  # Копирование резервной копии на резервный узел
  scp -r $LOCAL_BACKUP_DIR/* pg1:$REMOTE_BACKUP_DIR/
  # Проверка успешности копирования
  if [ $? -eq 0 ]; then
    echo "Резервная копия успешно перенесена на резервный узел: $REMOTE_BACKUP_DIR"
    # Удаление старых резервных копий на основном узле (старше 1 недели)
    find /var/db/postgres0/backups -type d -mtime +7 -exec rm -rf {} \;
    echo "Старые резервные копии удалены на основном узле"
    # Удаление старых резервных копий на резервном узле (старше 4 недель)
    ssh pg1 "find /var/db/postgres1/backups -type d -mtime +28 -exec rm -rf {} \;"
    echo "Старые резервные копии удалены на резервном узле"
  else
    echo "Ошибка при переносе резервной копии на резервный узел"
    exit 1
  fi
else
  echo "Ошибка при выполнении резервного копирования на основном узле"
  exit 1
fi
```

Добавим права на выполнение
```sh
chmod +x /var/db/postgres0/script1.sh
```

Настроим выполнение скрипта с помощью кроны раз в неделю
```sh
crontab -e
0 3 * * 1 /var/db/postgres0/script1.sh
```
#image("img/img.png")

=== Подсчет объемов и анализ результатов

Условия:
- Средний объем новых данных в БД за сутки: 350МБ.
- Средний объем измененных данных за сутки: 800МБ.

==== Расчет размеров бекапов

В сутки будет $350$ МБайт новых данных

Воспользуемся арифметической прогрессией

$ S_"back" = (2*0 + 350 * (30-1))/2 * 30 = 152250 "МБ" = 149 "ГБ"  $

Размер бекапов за месяц  - 149 Гб

==== Расчет размеров wal архивов

wal_segsize = 16 Мб

Объем изменений - 800 Мб -> 50 cегментов = размер wal_archive за сутки - 800Мб

$ S_"wal" = ((30-1) * 800) / 2 * 30 = 348000 "Мб" = 340 "Гб" $

==== Итоговый размер

$ S = S_"backup" + S_"wal" = 340 + 149 = 489 "Гб" $

Итого через месяц получаем 489 Гб бекапов





Условия:
- Средний объем новых данных в БД за сутки: 350МБ
- Средний объем измененных данных за сутки: 800МБ
- Резервные копии создаются раз в неделю
- Каждая резервная копия является полной + архивация WAL
650 МБ
= 325 МБ
2
Расчеты:
1. Объем данных за сутки:
• Новые данные: 300 МБ
• Измененные данные: 350 МБ
• Итого за сутки: 300 МБ + 350 МБ = 650 МБ
2. Объем данных за одну резервную копию:
Поскольку резервные копии создаются 2 раза в сутки, объем данных,
добавляемых за одну копию, будет:
Объем одной копии =
3. Объем данных за месяц:
• Количество дней в месяце: 30
• Количество резервных копий в сутки: 2
• Итого за месяц: 325 МБ/копия * 2 копии/день * 30 дней = 19 500 МБ
= 19,5 ГБ
4. Объем всех резервных копий за месяц:
Если каждая резервная копия является полной, то:
• Объем одной резервной копии увеличивается на 325 МБ каждые 12
часов
• Пример для первых двух дней:
o 1-я копия (день 1, 0:00–12:00): 325 МБ
o 2-я копия (день 1, 12:00–24:00): 325 + 325 = 650 МБ
o 3-я копия (день 2, 0:00–12:00): 650 + 325 = 975 МБ
o 4-я копия (день 2, 12:00–24:00): 975 + 325 = 1,300 МБ
Это арифметическая прогрессия, где:
• Первый член (a1) = 325 МБ
• Последний член (a60) = 325×60 = 19500 МБ
• Количество членов (n) = 60 (2 копии/день * 30 дней)
Сумма арифметической прогрессии:
𝑛 × (𝑎1 + 𝑎𝑛)
𝑆𝑛
=
60 × (325 + 19500)
𝑆60 =
2
= 594750 МБ = 594,75ГБ
2
Анализ результатов:
При использовании полных резервных копий 2 раза в сутки объем за месяц
составит 604,5 ГБ. Для того, чтобы оптимизировать, можно использовать
инкрементные резервные копии или сжатие. Инкрементные резервные копии
сохраняют только изменения с момента последней резервной копии. Это
значительно сократит объем хранимых данных. Если мы будем использовать
сжатие (например, gzip или zstd), то объем резервных копий уменьшится.
Коэффициент сжатия зависит от типа данных, но обычно составляет 2–4 раза.
Из плюсов: резервные копии старше определенного срока автоматически
удаляются.

== Этап 2. Потеря основного узла
Для восстановления воссоздадим файловую структуру кластера и табличного
пространства на резервном узле из нашего бэкапа:
```sh
mkdir -p /var/db/postgres1/u08/djs10
cp -r ~/backups/2025-04-06_20-13-07/* /var/db/postgres1/u08/djs10
chmod 750 /var/db/postgres1/u08/djs10
# Распакуем резервную копию:
cd ~/u08/djs10
tar -xzf base.tar.gz
tar -xzf pg_wal.tar.gz
tar -xzf 16387.tar.gz
tar -xzf 16388.tar.gz
# Укажем в postgresql.conf команду для загрузки wal-файлов:
echo "restore_command = 'cp /var/db/postgres1/wal_archive/%f %p'">> /var/db/postgres1/u08/djs10/postgresql.conf
# Создадим в директории кластера файл, сигнализирующий о восстановлении:
touch ~/u08/djs10/recovery.signal
# Запустим резервный кластер:
pg_ctl -D ~/u08/djs10 start
# Проверим статус:
pg_ctl -D ~/u08/djs10 status
```
#image("img/img_1.png")

Проверим таблицы в восстановленной бд:
```sh
psql -h pg109 -p 9455 -U new_user -d leftbrownmom
\d
```
#image("img/img_2.png")

== Этап 3. Повреждение файлов БД
Удалим директорию с WAL файлами и запустим сервер
#image("img/img_3.png")

Восстановим данные в новую директорию
```sh
mkdir -p ~/u08_new/djs10
chmod 750 ~/u08_new/djs10
cd ~/u08_new/djs10
# Распакуем резервную копию:
tar -xzf ~/backups/2025-04-06_19-29-44/base.tar.gz -C ~/u08_new/djs10
mkdir -p ~/u08_new/djs10/pg_wal
tar -xzf ~/backups/2025-04-06_19-29-44/pg_wal.tar.gz -C ~/u08_new/djs10/pg_wal
mkdir -p ~/cje38_new
tar -xzf ~/backups/2025-04-06_19-29-44/16387.tar.gz -C ~/cje38_new/
mkdir -p ~/qdx64_new
tar -xzf ~/backups/2025-04-06_19-29-44/16388.tar.gz -C ~/qdx64_new/
# Создадим в директории кластера файл, сигнализирующий о восстановлении:
touch ~/u08_new/djs10/recovery.signal
```
Укажем в postgresql.conf команду для загрузки wal файлов:
```conf
echo "restore_command = 'cp /home/postgres0/u08_new/djs10/pg_wal/%f %p'" > postgresql.conf
```

Запустим восстановленный кластер:
pg_ctl -D ~/u08_new/djs10 start
#image("img/img_5.png")
Подключимся к бд и посмотрим таблицы:
```sh
psql -h pg109 -p 9455 -U new_user -d leftbrownmom
\d
```
#image("img/img_5.png")
== Этап 4. Логическое повреждение данных

== Настраиваем архивирование и добавляем данные

==== Создадим таблицу с внешними ключами

```sql
CREATE TABLE IF NOT EXISTS students (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS lessons (
  id SERIAL PRIMARY KEY,
  student_id INTEGER NOT NULL,
  title TEXT NOT NULL,
  FOREIGN KEY (student_id) REFERENCES students(id)
);
```

==== Добавим тестовые записи

```sql
INSERT INTO students (name) VALUES
  ('Азат'),
  ('Ульяна');
INSERT INTO lessons (student_id, title) VALUES
  ((SELECT id FROM students WHERE name='Азат'), 'РСХД азат'),
  ((SELECT id FROM students WHERE name='Ульяна'), 'РСХД ульяна');
```

Посмотрим что получилось:

```sql
SELECT * from lessons join students on (student_id = students.id);
```

#image("img/select_result_4.png")

==== Зафиксируем время изменений

#image("img/error_time.png")

==== Создание дампа

Сделаем скрипт create_dump.sh

```sh
#!/bin/bash

dumps_dir="${HOME}/dumps/"
dump_name="db-$(date +"%m-%d-%Y-%H-%M-%S").dump"

pg_dump -h pg109 -p 9455 -d leftbrownmom -U new_user -Fc > $dumps_dir$dump_name
```

Добавим права на исполнение и исполним

```sh
chmod +x ${HOME}/create_dump.sh
mkdir dumps
bash ./create_dump.sh
```

==== Иммитация порчи данных

```sql
ALTER TABLE lessons DROP CONSTRAINT lessons_student_id_fkey;

UPDATE lessons
  SET student_id = 10000
WHERE id IN (
  SELECT id FROM lessons LIMIT 1
);

DELETE FROM students where name = 'Ульяна';
```

Посмотрим что получилось:

```sql
SELECT * from lessons join students on (student_id = students.id);
```

#image("img/select_result_after_drop.png")

==== Восстановление данных

Создадим скрипт
```sh
#!/bin/bash

dumps_dir="dumps/"

dump_name=$1

rsync --rsync-path=/usr/local/bin/rsync --archive postgres0@pg109:~/$dumps_dir$dump_name ~/
pg_restore -h pg114 -p 9455 -d leftbrownmom -U new_user -c $dump_name -v
rm -rf $dump_name
```

Выдадим разрешения и исполним
```sh
chmod +x ./restore_dump.sh

bash ./restore_dump.sh db-04-21-2025-02-03-47.dump
```

#image("img/restore_result.png")

Посмотрим что мы увидим в таблице

```sql
SELECT * from lessons join students on (student_id = students.id);
```

#image("img/restore_result_tables.png")

Итого: данные удалось восстановить

= Вывод

В ходе выполнения данной лабораторной работы мы настроили создание бекапов postgresql, и испытали при различных условиях:
полной потери основного узла, повреждении файлов БД или логического повреждения данных.
