#set text(
  font: "Times New Roman",
  size: 14pt
)
#set quote(block: true)

#align(center)[Министерство науки и высшего образования Российской Федерации]
#align(center)[Федеральное государственное автономное образовательное учреждение]
#align(center)[Высшего образования]
#align(center)[_Факультет Программной Инженерии и Компьютерной Техники_]

#v(8em)

#align(center)[*Лабораторная работа 3 по РСХД*]
#align(center)[Вариант 51486]

#v(8em)

#align(right)[Группа: P3316]
#align(right)[Выполнили:]
#align(right)[Сиразетдинов, Шпинева]
#align(right)[Проверил:]
#align(right)[Николаев В.В.]

#v(8em)

#align(center)[г. Санкт-Петербург]
#align(center)[2025]

#pagebreak()

= Задание

== Цель работы

Цель работы - настроить процедуру периодического резервного копирования базы данных, сконфигурированной в ходе
выполнения лабораторной работы №2, а также разработать и отладить сценарии восстановления в случае сбоев.

Узел из предыдущей лабораторной работы используется в качестве основного. Новый узел используется в качестве резервного.
Учётные данные для подключения к новому узлу выдаёт преподаватель. В сценариях восстановления необходимо использовать
копию данных, полученную на первом этапе данной лабораторной работы.

== Этап 1. Резервное копирование
- Настроить резервное копирование с основного узла на резервный следующим образом:
Периодические полные копии + непрерывное архивирование.
Включить для СУБД режим архивирования WAL; настроить копирование WAL (```scp```) на резервный узел; настроить полное
резервное копирование (pg_basebackup) по расписанию (cron) раз в неделю. Созданные полные копии должны сразу
копироваться (scp) на резервный хост. Срок хранения копий на основной системе - 1 неделя, на резервной - 4 недели.
По истечении срока хранения, старые архивы и неактуальные WAL должны автоматически уничтожаться.

- Подсчитать, каков будет объем резервных копий спустя месяц работы системы, исходя из следующих условий:
Средний объем новых данных в БД за сутки: 350МБ.
Средний объем измененных данных за сутки: 800МБ.
- Проанализировать результаты.

== Этап 2. Потеря основного узла
Этот сценарий подразумевает полную недоступность основного узла. Необходимо восстановить работу СУБД на РЕЗЕРВНОМ узле,
продемонстрировать успешный запуск СУБД и доступность данных.

== Этап 3. Повреждение файлов БД
Этот сценарий подразумевает потерю данных (например, в результате сбоя диска или файловой системы) при сохранении
доступности основного узла. Необходимо выполнить полное восстановление данных из резервной копии и перезапустить СУБД
на ОСНОВНОМ узле.

Ход работы:

- Симулировать сбой:
    - удалить с диска директорию WAL со всем содержимым.
- Проверить работу СУБД, доступность данных, перезапустить СУБД, проанализировать результаты.
- Выполнить восстановление данных из резервной копии, учитывая следующее условие:
    - исходное расположение дополнительных табличных пространств недоступно - разместить в другой директории и
    скорректировать конфигурацию.
- Запустить СУБД, проверить работу и доступность данных, проанализировать результаты.

== Этап 4. Логическое повреждение данных
Этот сценарий подразумевает частичную потерю данных (в результате нежелательной или ошибочной операции) при сохранении
 доступности основного узла. Необходимо выполнить восстановление данных на ОСНОВНОМ узле следующим способом:

- Генерация файла на резервном узле с помощью pg_dump и последующее применение файла на основном узле.

Ход работы:
- В каждую таблицу базы добавить 2-3 новые строки, зафиксировать результат.
- Зафиксировать время и симулировать ошибку:
    - в любой таблице с внешними ключами подменить значения ключей на случайные (INSERT, UPDATE)
- Продемонстрировать результат.
- Выполнить восстановление данных указанным способом.
- Продемонстрировать и проанализировать результат.


= Выполнение

== Этап 1. Резервное копирование

На основном узле зададим параметры для архивации WAL файлов и их копирования на резервный узел:
```conf
wal_level = replica
archive_mode = on
archive_command = 'scp %p postgres1@pg114:/var/db/postgres1/wal_archive/%f'
```

Подключимся как суперпользователь
```sh
psql -h localhost -p 9455 -U postgres0 -d postgres
```
Создадим роль replicator с правами на репликацию:
```sql
CREATE ROLE replicator WITH REPLICATION LOGIN PASSWORD
'pass123';
```
Напишем скрипт для создания копии:
```sh
#!/bin/bash
# Директория для хранения резервных копий на основном узле
LOCAL_BACKUP_DIR="/var/db/postgres0/backups/$(date +%Y-%m-%d_%H-%M-%S)"
# Директория для хранения резервных копий на резервном узле
REMOTE_BACKUP_DIR="/var/db/postgres1/backups/$(date +%Y-%m-%d_%H-%M-%S)"
# Создание директории на основном узле
mkdir -p $LOCAL_BACKUP_DIR
# Создание директории на резервном узле
ssh postgres1@pg114 "mkdir -p $REMOTE_BACKUP_DIR"

# Выполнение резервного копирования на основном узле
pg_basebackup -D $LOCAL_BACKUP_DIR -Ft -z -Xs -P -U replicator -h pg109 -p 9455
# Проверка успешности выполнения
if [ $? -eq 0 ]; then
  echo "Резервное копирование успешно завершено на основном узле: $LOCAL_BACKUP_DIR"
  # Копирование резервной копии на резервный узел
  scp -r $LOCAL_BACKUP_DIR/* postgres1@pg114:$REMOTE_BACKUP_DIR/
  # Проверка успешности копирования
  if [ $? -eq 0 ]; then
    echo "Резервная копия успешно перенесена на резервный узел: $REMOTE_BACKUP_DIR"
    # Удаление старых резервных копий на основном узле (старше 1 недели)
    find /var/db/postgres0/backups -type d -mtime +7 -exec rm -rf {} \;
    echo "Старые резервные копии удалены на основном узле"
    # Удаление старых резервных копий на резервном узле (старше 4 недель)
    ssh postgres1@pg114 "find /var/db/postgres1/backups -type d -mtime +28 -exec rm -rf {} \;"
    echo "Старые резервные копии удалены на резервном узле"
  else
    echo "Ошибка при переносе резервной копии на резервный узел"
    exit 1
  fi
else
  echo "Ошибка при выполнении резервного копирования на основном узле"
  exit 1
fi
```

Добавим права на выполнение
```sh
chmod +x /var/db/postgres0/script1.sh
```

Настроим выполнение скрипта с помощью кроны раз в неделю
```sh
crontab -e
0 3 * * 1 /var/db/postgres0/script1.sh
```
#image("img/img.png")

=== Подсчет объемов и анализ результатов

== Этап 2. Потеря основного узла
Для восстановления воссоздадим файловую структуру кластера и табличного
пространства на резервном узле из нашего бэкапа:
```sh
mkdir -p /var/db/postgres1/u08/djs10
cp -r ~/backups/2025-04-06_20-13-07/* /var/db/postgres1/u08/djs10
chmod 750 /var/db/postgres1/u08/djs10
# Распакуем резервную копию:
cd ~/u08/djs10
tar -xzf base.tar.gz
tar -xzf pg_wal.tar.gz
tar -xzf 16387.tar.gz
tar -xzf 16388.tar.gz
# Укажем в postgresql.conf команду для загрузки wal-файлов:
echo "restore_command = 'cp /var/db/postgres1/u08/djs10/%f %p'" >> /var/db/postgres1/u08/djs10/postgresql.conf
# Создадим в директории кластера файл, сигнализирующий о восстановлении:
touch ~/u08/djs10/recovery.signal
# Запустим резервный кластер:
pg_ctl -D ~/u08/djs10 start
# Проверим статус:
pg_ctl -D ~/u08/djs10 status
```
#image("img/img_1.png")

Проверим таблицы в восстановленной бд:
```sh
psql -h pg109 -p 9455 -U new_user -d leftbrownmom
\d
```
#image("img/img_2.png")

== Этап 3. Повреждение файлов БД
Удалим директорию с WAL файлами и запустим сервер
#image("img/img_3.png")

Восстановим данные в новую директорию
```sh
mkdir -p ~/u08_new/djs10
chmod 750 ~/u08_new/djs10
cd ~/u08_new/djs10
# Распакуем резервную копию:
tar -xzf ~/backups/2025-04-06_19-29-44/base.tar.gz -C ~/u08_new/djs10
mkdir -p ~/u08_new/djs10/pg_wal
tar -xzf ~/backups/2025-04-06_19-29-44/pg_wal.tar.gz -C ~/u08_new/djs10/pg_wal
mkdir -p ~/cje38_new
tar -xzf ~/backups/2025-04-06_19-29-44/16387.tar.gz -C ~/cje38_new/
mkdir -p ~/qdx64_new
tar -xzf ~/backups/2025-04-06_19-29-44/16388.tar.gz -C ~/qdx64_new/
# Создадим в директории кластера файл, сигнализирующий о восстановлении:
touch ~/u08_new/djs10/recovery.signal
```
Укажем в postgresql.conf команду для загрузки wal файлов:
```conf
echo "restore_command = 'cp /home/postgres0/u08_new/djs10/pg_wal/%f %p'" > postgresql.conf
```

Запустим восстановленный кластер:
pg_ctl -D ~/u08_new/djs10 start
#image("img/img_5.png")
Подключимся к бд и посмотрим таблицы:
```sh
psql -h pg109 -p 9455 -U new_user -d leftbrownmom
\d
```
#image("img/img_5.png")
== Этап 4. Логическое повреждение данных
```sh
archive_mode = on
archive_command = 'scp %p postgres1@pg114:/var/db/postgres1/wal_archive/%f'
archive_timeout = 60
restore_command = 'cp /var/db/postgres1/u08/djs10/pg_wal/%f %p'
```

= Вывод
